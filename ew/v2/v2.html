<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Design & Earthwork Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>

    <style>
        /* Basic styling for D3 charts */
        .grid path, .grid line {
            fill: none;
            stroke: #e2e8f0; /* slate-200 */
            shape-rendering: crispEdges;
        }
        .axis path, .axis line {
            fill: none;
            stroke: #475569; /* slate-600 */
        }
        .axis text {
            fill: #475569; /* slate-600 */
            font-size: 10px;
        }
        .line-egl {
            fill: none;
            stroke: #2563eb; /* blue-600 */
            stroke-width: 1.5px;
        }
        .line-pfl {
            fill: none;
            stroke: #dc2626; /* red-600 */
            stroke-width: 2px;
            stroke-dasharray: 4;
        }
        .area-cut { fill: #ef4444; opacity: 0.3; } /* red-500 */
        .area-fill { fill: #22c55e; opacity: 0.3; } /* green-500 */
        .cursor-line {
            stroke: #f59e0b; /* amber-500 */
            stroke-width: 1.5px;
            pointer-events: none;
        }
        #report-table th, #report-table td { padding: 4px 8px; border: 1px solid #cbd5e1; text-align: right; }
        #report-table th { background-color: #f1f5f9; position: sticky; top: 0; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 font-sans">
    <div class="flex flex-col h-screen">
        <header class="bg-white shadow-md p-2 flex justify-between items-center">
            <h1 class="text-xl font-bold text-slate-700">üõ£Ô∏è Preliminary Road Design Studio</h1>
            <div id="status-message" class="text-sm font-medium text-blue-600">Please load survey data to begin.</div>
        </header>

        <main class="flex-grow flex p-2 gap-2 overflow-hidden">
            <aside class="w-1/4 bg-white rounded-lg shadow p-3 overflow-y-auto flex flex-col gap-4">
                <section>
                    <h2 class="font-bold border-b pb-1 mb-2">1. Data Ingestion</h2>
                    <label for="file-input" class="w-full cursor-pointer bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded text-center block">
                        Load Survey Data (.csv, .sdr)
                    </label>
                    <input type="file" id="file-input" class="hidden" accept=".csv,.sdr">
                </section>

                <section>
                    <h2 class="font-bold border-b pb-1 mb-2">2. Project Configuration</h2>
                    <form id="config-form" class="grid grid-cols-2 gap-x-3 gap-y-2 text-sm">
                        <label for="centerlineCode">Centerline Code</label><input type="text" id="centerlineCode" class="border p-1 rounded">
                        <label for="chainageInterval">Interval (m)</label><input type="number" id="chainageInterval" class="border p-1 rounded">
                        <label for="carriagewayWidth">Carriageway (m)</label><input type="number" id="carriagewayWidth" class="border p-1 rounded">
                        <label for="shoulderWidth">Shoulder (m)</label><input type="number" id="shoulderWidth" class="border p-1 rounded">
                        <label for="camberSlope">Camber (%)</label><input type="number" id="camberSlope" class="border p-1 rounded">
                        <label for="shoulderSlope">Shoulder Slope (%)</label><input type="number" id="shoulderSlope" class="border p-1 rounded">
                        <label for="cutSlope">Cut Slope (1:N)</label><input type="number" id="cutSlope" class="border p-1 rounded">
                        <label for="fillSlope">Fill Slope (1:N)</label><input type="number" id="fillSlope" class="border p-1 rounded">
                        <label for="bulkingFactor">Bulking Factor</label><input type="number" step="0.01" id="bulkingFactor" class="border p-1 rounded">
                        <label for="compactionFactor">Compaction Factor</label><input type="number" step="0.01" id="compactionFactor" class="border p-1 rounded">
                        <label for="cutRate">Cut Rate (per m¬≥)</label><input type="number" id="cutRate" class="border p-1 rounded">
                        <label for="fillRate">Fill Rate (per m¬≥)</label><input type="number" id="fillRate" class="border p-1 rounded">
                    </form>
                </section>
                
                 <section>
                    <h2 class="font-bold border-b pb-1 mb-2">3. PFL Design Controls</h2>
                    <div class="flex gap-2">
                         <button id="btn-set-gradient" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded text-sm">Set Gradient</button>
                         <button id="btn-add-ip" class="flex-1 bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded text-sm">Add IP</button>
                    </div>
                    <div id="ip-list" class="mt-2 text-sm"></div>
                    <button id="btn-reset-pfl" class="w-full mt-2 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded text-sm">Reset PFL</button>
                </section>

                <section>
                    <h2 class="font-bold border-b pb-1 mb-2">4. Reporting</h2>
                     <button id="btn-generate-report" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded">Generate Earthwork Report</button>
                    <div id="summary-box" class="mt-3 bg-slate-50 p-2 rounded border hidden">
                         <h3 class="font-semibold text-center mb-1">Summary</h3>
                         <div class="grid grid-cols-2 gap-1 text-sm">
                            <span>Total Cut (Adj):</span><span id="total-cut" class="font-mono text-right">0.00 m¬≥</span>
                            <span>Total Fill (Adj):</span><span id="total-fill" class="font-mono text-right">0.00 m¬≥</span>
                            <span class="font-bold">Total Cost:</span><span id="total-cost" class="font-bold font-mono text-right">‚Çπ 0.00</span>
                         </div>
                         <button id="btn-export-csv" class="w-full mt-3 bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-3 rounded text-sm">Export to CSV</button>
                    </div>
                </section>
            </aside>
            
            <main class="w-3/4 flex flex-col gap-2">
                <div class="flex-grow flex gap-2 h-3/5">
                    <div class="w-1/2 bg-white rounded-lg shadow p-1 relative">
                        <div id="view3d-container" class="w-full h-full rounded"></div>
                        <span class="absolute top-2 left-2 bg-black/50 text-white text-xs px-2 py-1 rounded">3D View</span>
                    </div>
                    <div class="w-1/2 bg-white rounded-lg shadow p-1 relative">
                        <div id="viewLSection-container" class="w-full h-full rounded"></div>
                         <span class="absolute top-2 left-2 bg-black/50 text-white text-xs px-2 py-1 rounded">Longitudinal Section</span>
                    </div>
                </div>
                <div class="flex-grow flex gap-2 h-2/5">
                     <div class="w-1/2 bg-white rounded-lg shadow p-1 relative">
                         <div id="viewXSection-container" class="w-full h-full rounded"></div>
                         <span class="absolute top-2 left-2 bg-black/50 text-white text-xs px-2 py-1 rounded">Cross Section @ Chainage <span id="xsection-chainage">0.00</span>m</span>
                         <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded font-mono">
                            Cut: <span id="xsection-cut-area">0.00</span> m¬≤ | Fill: <span id="xsection-fill-area">0.00</span> m¬≤
                         </div>
                    </div>
                    <div class="w-1/2 bg-white rounded-lg shadow p-2 flex flex-col">
                        <h3 class="font-bold mb-1">Earthwork Volume Report</h3>
                        <div id="report-container" class="flex-grow overflow-y-auto text-xs">
                           <table id="report-table" class="w-full border-collapse">
                               <thead>
                                   <tr><th>Chainage</th><th>Cut Area</th><th>Fill Area</th><th>Cut Vol.</th><th>Fill Vol.</th></tr>
                               </thead>
                               <tbody>
                                    <tr><td colspan="5" class="text-center p-4">Report not generated.</td></tr>
                               </tbody>
                           </table>
                        </div>
                    </div>
                </div>
            </main>
        </main>
    </div>

<script type="module">
// ===================================================================================
// APP ORCHESTRATOR & GLOBAL STATE
// ===================================================================================
const App = {
    // Global state to hold all application data
    state: {
        rawPoints: [],
        centerline: [],
        config: {},
        pfl: {
            type: 'none', // 'gradient' or 'ips'
            points: [], // For gradient: [p1, p2]. For IPs: [ip1, ip2, ...]
            verticalCurves: [], // [{ip, length, vpc, vpt, ...}]
        },
        reportData: [],
    },

    // Initialize the entire application
    init() {
        console.log("App Initializing...");
        Config.init();
        UI.initEventListeners();
        Viz.initAll();
        UI.updateStatus("Ready. Please load survey data.", "blue");
    },
    
    // Main processing pipeline after file load
    async processNewData(fileContent, fileExtension) {
        UI.updateStatus("Parsing survey data...", "orange");
        try {
            // 1. Parse Data
            const points = fileExtension === '.csv' 
                ? Parser.parseCSV(fileContent) 
                : Parser.parseSDR(fileContent);

            if (points.length === 0) throw new Error("No valid points found in the file.");
            this.state.rawPoints = points;
            UI.updateStatus(`Successfully loaded ${points.length} points.`, "green");

            // 2. Process Centerline
            this.processCenterline();

        } catch (error) {
            UI.handleError(error.message);
        }
    },

    // Extracts, sorts, and calculates chainages for the centerline
    processCenterline() {
        UI.updateStatus("Processing centerline...", "orange");
        const clCode = this.state.config.centerlineCode;
        let clPoints = this.state.rawPoints.filter(p => p.code.toUpperCase() === clCode.toUpperCase());
        
        if (clPoints.length < 2) {
            throw new Error(`Centerline code '${clCode}' found in ${clPoints.length} points. At least 2 are required.`);
        }

        // Simple sort by 'y' (Northing) assuming a generally North-South alignment
        // A more robust solution would use a nearest-neighbor search from a designated start point.
        clPoints.sort((a, b) => a.y - b.y);

        // Calculate chainage
        let currentChainage = 0;
        clPoints[0].chainage = 0;
        for (let i = 1; i < clPoints.length; i++) {
            const p1 = clPoints[i-1];
            const p2 = clPoints[i];
            const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            currentChainage += dist;
            p2.chainage = currentChainage;
        }

        this.state.centerline = clPoints;
        UI.updateStatus(`Centerline processed with ${clPoints.length} points. Total length: ${currentChainage.toFixed(2)}m`, "green");
        
        // 3. Trigger visualizations
        this.resetPFL();
        Viz.LSection.draw(this.state.centerline, this.getPFLAtChainage);
        Viz.ThreeD.drawEGL(this.state.rawPoints);
    },

    // Resets the Proposed Formation Level
    resetPFL() {
        this.state.pfl = { type: 'none', points: [], verticalCurves: [] };
        UI.updatePFLList();
        Viz.LSection.draw(this.state.centerline, this.getPFLAtChainage);
        Report.clear();
    },
    
    // Defines PFL based on a simple two-point gradient
    setPFLWithGradient(p1, p2) {
        this.state.pfl.type = 'gradient';
        this.state.pfl.points = [p1, p2];
        Viz.LSection.draw(this.state.centerline, this.getPFLAtChainage);
        UI.updateStatus('PFL set by gradient.', 'green');
    },

    // Adds an Intersection Point (IP) for vertical curve design
    addPFLIP(point) {
        this.state.pfl.type = 'ips';
        this.state.pfl.points.push(point);
        this.state.pfl.points.sort((a, b) => a.chainage - b.chainage);
        this.calculateVerticalCurves();
        UI.updatePFLList();
        Viz.LSection.draw(this.state.centerline, this.getPFLAtChainage);
        UI.updateStatus('IP added. Enter curve length if needed.', 'green');
    },
    
    // Calculates all vertical curve parameters
    calculateVerticalCurves() {
        const { points: ips } = this.state.pfl;
        if (ips.length < 2) {
            this.state.pfl.verticalCurves = [];
            return;
        }
        
        const curves = [];
        for (let i = 0; i < ips.length; i++) {
            if(i === 0 || i === ips.length - 1) continue; // Curves are only at intermediate IPs

            const g1_p1 = ips[i-1];
            const g1_p2 = ips[i];
            const g2_p1 = ips[i];
            const g2_p2 = ips[i+1];
            
            const g1 = (g1_p2.z - g1_p1.z) / (g1_p2.chainage - g1_p1.chainage);
            const g2 = (g2_p2.z - g2_p1.z) / (g2_p2.chainage - g2_p1.chainage);
            
            const L = ips[i].curveLength || 0; // Get user-defined length
            
            if(L > 0) {
                 curves.push({
                    ip: ips[i],
                    L: L,
                    g1: g1,
                    g2: g2,
                    vpcChainage: ips[i].chainage - L / 2,
                    vpcElevation: ips[i].z - g1 * (L / 2),
                    vptChainage: ips[i].chainage + L / 2,
                });
            }
        }
        this.state.pfl.verticalCurves = curves;
    },

    // The main function to get PFL elevation at any chainage
    getPFLAtChainage(chainage) {
        const { type, points, verticalCurves } = App.state.pfl;

        if (type === 'gradient' && points.length === 2) {
            const [p1, p2] = points;
            if (p2.chainage === p1.chainage) return p1.z;
            const m = (p2.z - p1.z) / (p2.chainage - p1.chainage);
            return p1.z + m * (chainage - p1.chainage);
        }
        
        if (type === 'ips' && points.length > 1) {
            // Check if on a vertical curve
            for (const curve of verticalCurves) {
                if (chainage >= curve.vpcChainage && chainage <= curve.vptChainage) {
                    const x = chainage - curve.vpcChainage;
                    const Z_curve = curve.vpcElevation + curve.g1 * x + ((curve.g2 - curve.g1) / (2 * curve.L)) * x * x;
                    return Z_curve;
                }
            }

            // Otherwise, on a tangent
            let p1 = points[0], p2 = points[1];
            for (let i = 0; i < points.length - 1; i++) {
                if (chainage >= points[i].chainage && chainage <= points[i+1].chainage) {
                    p1 = points[i];
                    p2 = points[i+1];
                    break;
                }
            }
             if (chainage > points[points.length-1].chainage) {
                p1 = points[points.length-2];
                p2 = points[points.length-1];
            }

            if (p2.chainage === p1.chainage) return p1.z;
            const m = (p2.z - p1.z) / (p2.chainage - p1.chainage);
            return p1.z + m * (chainage - p1.chainage);
        }
        
        return null; // No PFL defined
    },
};

// ===================================================================================
// MODULE 1: DATA INGESTION & PARSING
// ===================================================================================
const Parser = {
    // Parses standard CSV: PointID,Easting,Northing,Elevation,Code
    parseCSV(text) {
        const points = [];
        const lines = text.split('\n').filter(line => line.trim() !== '');
        // Skip header if it contains non-numeric values in coordinate fields
        const hasHeader = isNaN(parseFloat(lines[0].split(',')[1]));
        const dataLines = hasHeader ? lines.slice(1) : lines;

        dataLines.forEach((line, index) => {
            const parts = line.split(',');
            if (parts.length >= 5) {
                const point = {
                    id: parts[0].trim(),
                    x: parseFloat(parts[1]), // Easting
                    y: parseFloat(parts[2]), // Northing
                    z: parseFloat(parts[3]), // Elevation
                    code: parts[4].trim(),
                };
                if (!isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z)) {
                    points.push(point);
                }
            }
        });
        return points;
    },

    // Parses Sokkia SDR33 coordinate records
    parseSDR(text) {
        const points = [];
        const lines = text.split('\n');
        // Regex for SDR33 coordinate record (09F1...)
        const sdrRegex = /^09F1\s*([\w-]*)\s*([\d\.\- ]{15})([\d\.\- ]{15})([\d\.\- ]{15})/;
        
        lines.forEach(line => {
            const match = line.match(sdrRegex);
            if (match) {
                const point = {
                    id: match[1].trim(),
                    // SDR format is Northing, Easting, Elevation
                    y: parseFloat(match[2].trim()), // Northing
                    x: parseFloat(match[3].trim()), // Easting
                    z: parseFloat(match[4].trim()), // Elevation
                    code: match[0].substring(68).trim() // Code is in the remaining part
                };
                 if (!isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z)) {
                    points.push(point);
                }
            }
        });
        return points;
    },
};

// ===================================================================================
// MODULE 2: CONFIGURATION
// ===================================================================================
const Config = {
    // Default values for an Indian State Highway / Major District Road
    defaults: {
        centerlineCode: "CL",
        chainageInterval: 20,
        carriagewayWidth: 7.0,
        shoulderWidth: 1.5,
        camberSlope: -2.5,
        shoulderSlope: -3.5,
        cutSlope: 1.5, // 1V:1.5H
        fillSlope: 2.0, // 1V:2.0H
        bulkingFactor: 1.15,
        compactionFactor: 0.92,
        cutRate: 150, // INR
        fillRate: 120 // INR
    },
    
    // Load defaults and bind to form
    init() {
        this.load(this.defaults);
        document.getElementById('config-form').addEventListener('input', (e) => {
            this.update(e.target.id, e.target.value);
        });
    },

    // Load a config object into the global state and UI form
    load(configObj) {
        App.state.config = { ...configObj };
        for (const key in configObj) {
            const el = document.getElementById(key);
            if (el) el.value = configObj[key];
        }
    },
    
    // Update a single config value in the global state
    update(key, value) {
        if (App.state.config.hasOwnProperty(key)) {
             App.state.config[key] = isNaN(parseFloat(value)) ? value : parseFloat(value);
        }
        // If centerline code changes, re-process data
        if(key === 'centerlineCode' && App.state.rawPoints.length > 0) {
            try {
                App.processCenterline();
            } catch(e) {
                UI.handleError(e.message);
            }
        }
    }
};

// ===================================================================================
// MODULE 4: VISUALIZATION (3D, L-Section, X-Section)
// ===================================================================================
const Viz = {
    // D3 chart margins
    margin: { top: 20, right: 30, bottom: 30, left: 40 },
    
    // Initialize all visualization components
    initAll() {
        this.ThreeD.init();
        this.LSection.init();
        this.XSection.init();
    },
    
    // --- 3D View (Three.js) ---
    ThreeD: {
        scene: null, camera: null, renderer: null, controls: null,
        
        init() {
            const container = document.getElementById('view3d-container');
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            this.camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 50000);
            this.camera.position.set(500, 500, 500);
            
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(this.renderer.domElement);
            
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 500, 300);
            this.scene.add(directionalLight);

            const animate = () => {
                requestAnimationFrame(animate);
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            };
            animate();

            window.addEventListener('resize', () => this.onResize());
        },
        
        onResize() {
            const container = document.getElementById('view3d-container');
            this.camera.aspect = container.clientWidth / container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        drawEGL(points) {
            // Clear previous EGL
            const existingEGL = this.scene.getObjectByName("EGL_TIN");
            if (existingEGL) this.scene.remove(existingEGL);

            if (points.length < 3) return;
            
            // Center the camera on the data
            const box = new THREE.Box3().setFromPoints(points.map(p => new THREE.Vector3(p.x, p.y, p.z)));
            const center = box.getCenter(new THREE.Vector3());
            this.controls.target.copy(center);
            this.camera.position.set(center.x, center.y + 1000, center.z + 1000);

            const vertices = [];
            const xy_coords = [];
            points.forEach(p => {
                vertices.push(p.x, p.z, -p.y); // Y-up in 3D, so map Z to Y and invert Northing
                xy_coords.push(p.x, -p.y);
            });
            
            const triangles = earcut(xy_coords, null, 2);
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(triangles);
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x964B00, 
                side: THREE.DoubleSide, 
                wireframe: true,
                opacity: 0.7,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = "EGL_TIN";
            this.scene.add(mesh);
        }
    },
    
    // --- L-Section View (D3.js) ---
    LSection: {
        svg: null, x: null, y: null, width: 0, height: 0,
        
        init() {
            const container = document.getElementById('viewLSection-container');
            this.width = container.clientWidth - Viz.margin.left - Viz.margin.right;
            this.height = container.clientHeight - Viz.margin.top - Viz.margin.bottom;
            
            this.svg = d3.select(container)
                .append("svg")
                .attr("width", this.width + Viz.margin.left + Viz.margin.right)
                .attr("height", this.height + Viz.margin.top + Viz.margin.bottom)
                .append("g")
                .attr("transform", `translate(${Viz.margin.left},${Viz.margin.top})`);
            
            this.svg.append("g").attr("class", "grid x");
            this.svg.append("g").attr("class", "grid y");
            this.svg.append("g").attr("class", "axis x");
            this.svg.append("g").attr("class", "axis y");
            this.svg.append("path").attr("class", "line-egl");
            this.svg.append("path").attr("class", "line-pfl");
            this.svg.append("g").attr("class", "ip-markers");

            // Overlay for events
            const overlay = this.svg.append("rect")
                .attr("width", this.width)
                .attr("height", this.height)
                .style("fill", "none")
                .style("pointer-events", "all");

            const cursorLine = this.svg.append("line").attr("class", "cursor-line").attr("y1", 0).attr("y2", this.height).style("opacity", 0);

            overlay.on("mousemove", (event) => {
                if (!App.state.centerline || App.state.centerline.length === 0) return;
                const [mx] = d3.pointer(event);
                const chainage = this.x.invert(mx);
                cursorLine.attr("x1", mx).attr("x2", mx).style("opacity", 1);
                UI.broadcastChainage(chainage);
            });
            overlay.on("mouseout", () => cursorLine.style("opacity", 0));
            
            overlay.on("click", (event) => {
                const [mx, my] = d3.pointer(event);
                const chainage = this.x.invert(mx);
                const elevation = this.y.invert(my);
                UI.handleLSectionClick({ chainage, z: elevation });
            });
        },
        
        draw(centerline, getPFLFunc) {
            if (centerline.length === 0) return;

            const data = centerline.map(p => ({ chainage: p.chainage, z: p.z }));
            
            this.x = d3.scaleLinear().domain(d3.extent(data, d => d.chainage)).range([0, this.width]);
            this.y = d3.scaleLinear().domain(d3.extent(data, d => d.z)).range([this.height, 0]).nice();
            
            this.svg.select(".axis.x").attr("transform", `translate(0, ${this.height})`).call(d3.axisBottom(this.x).ticks(5).tickFormat(d => `${d/1000}k`));
            this.svg.select(".axis.y").call(d3.axisLeft(this.y).ticks(5));

            // EGL line
            this.svg.select(".line-egl").datum(data).attr("d", d3.line().x(d => this.x(d.chainage)).y(d => this.y(d.z)));

            // PFL line
            const pflData = this.x.ticks(200).map(ch => ({ chainage: ch, z: getPFLFunc(ch) })).filter(d => d.z !== null);
            if (pflData.length > 0) {
                this.svg.select(".line-pfl").datum(pflData).attr("d", d3.line().x(d => this.x(d.chainage)).y(d => this.y(d.z)));
            } else {
                 this.svg.select(".line-pfl").attr("d", null);
            }
            
            // IP markers
            const ips = App.state.pfl.points;
            this.svg.select(".ip-markers").selectAll("circle")
                .data(ips)
                .join("circle")
                .attr("cx", d => this.x(d.chainage))
                .attr("cy", d => this.y(d.z))
                .attr("r", 5)
                .attr("fill", "red")
                .attr("stroke", "white");
        }
    },

    // --- Cross-Section View (D3.js) ---
    XSection: {
        svg: null, x: null, y: null, width: 0, height: 0,
        
        init() {
            const container = document.getElementById('viewXSection-container');
            this.width = container.clientWidth - Viz.margin.left - Viz.margin.right;
            this.height = container.clientHeight - Viz.margin.top - Viz.margin.bottom;
            
            this.svg = d3.select(container)
                .append("svg")
                .attr("width", this.width + Viz.margin.left + Viz.margin.right)
                .attr("height", this.height + Viz.margin.top + Viz.margin.bottom)
                .append("g")
                .attr("transform", `translate(${Viz.margin.left},${Viz.margin.top})`);
            
            this.svg.append("g").attr("class", "grid x");
            this.svg.append("g").attr("class", "grid y");
            this.svg.append("g").attr("class", "axis x");
            this.svg.append("g").attr("class", "axis y");
            this.svg.append("path").attr("class", "area-cut");
            this.svg.append("path").attr("class", "area-fill");
            this.svg.append("path").attr("class", "line-egl");
            this.svg.append("path").attr("class", "line-road");
        },

        draw(chainage) {
            const data = XSectionHelper.generate(chainage);
            if (!data) return;

            const {egl, road, cutArea, fillArea} = data;
            
            const allPoints = [...egl, ...road];
            this.x = d3.scaleLinear().domain(d3.extent(allPoints, d => d.x)).range([0, this.width]).nice();
            this.y = d3.scaleLinear().domain(d3.extent(allPoints, d => d.y)).range([this.height, 0]).nice();
            
            this.svg.select(".axis.x").attr("transform", `translate(0, ${this.height})`).call(d3.axisBottom(this.x).ticks(5));
            this.svg.select(".axis.y").call(d3.axisLeft(this.y).ticks(5));
            
            const lineGen = d3.line().x(d => this.x(d.x)).y(d => this.y(d.y));

            this.svg.select(".line-egl").datum(egl).attr("d", lineGen);
            this.svg.select(".line-road").datum(road).attr("d", lineGen).style('stroke', '#c026d3').style('stroke-width', '2px');

            this.svg.select(".area-cut").datum(cutArea).attr("d", d3.area().x(d => this.x(d.x)).y0(this.height).y1(d => this.y(d.y)));
            this.svg.select(".area-fill").datum(fillArea).attr("d", d3.area().x(d => this.x(d.x)).y0(d => this.y(d.y)).y1(this.y(this.y.domain()[0])));

            UI.updateXSectionInfo(chainage, data.cutAreaValue, data.fillAreaValue);
        },
    }
};

// ===================================================================================
// MODULE 5: REPORTING ENGINE & HELPERS
// ===================================================================================
const Report = {
    generate() {
        if (App.state.centerline.length < 2 || App.state.pfl.type === 'none') {
            UI.handleError("Cannot generate report. Define a PFL first.");
            return;
        }
        
        UI.updateStatus("Generating report...", "orange");
        const { chainageInterval, bulkingFactor, compactionFactor, cutRate, fillRate } = App.state.config;
        const endChainage = App.state.centerline[App.state.centerline.length-1].chainage;
        
        let reportData = [];
        let lastAreas = { cut: 0, fill: 0 };
        let totalCutVol = 0;
        let totalFillVol = 0;

        for (let ch = 0; ch <= endChainage; ch += chainageInterval) {
            const xsection = XSectionHelper.generate(ch);
            const currentAreas = { cut: xsection.cutAreaValue, fill: xsection.fillAreaValue };

            const cutVol = (ch > 0) ? (lastAreas.cut + currentAreas.cut) / 2 * chainageInterval : 0;
            const fillVol = (ch > 0) ? (lastAreas.fill + currentAreas.fill) / 2 * chainageInterval : 0;
            
            totalCutVol += cutVol;
            totalFillVol += fillVol;

            reportData.push({
                chainage: ch,
                cutArea: currentAreas.cut,
                fillArea: currentAreas.fill,
                cutVol: cutVol,
                fillVol: fillVol,
            });
            lastAreas = currentAreas;
        }
        
        App.state.reportData = reportData;
        
        const adjustedCut = totalCutVol * bulkingFactor;
        const adjustedFill = totalFillVol * compactionFactor;
        const totalCost = (adjustedCut * cutRate) + (adjustedFill * fillRate);
        
        this.display(reportData);
        UI.updateSummary(adjustedCut, adjustedFill, totalCost);
        UI.updateStatus("Report generated successfully.", "green");
    },
    
    display(data) {
        const tbody = document.querySelector("#report-table tbody");
        tbody.innerHTML = ""; // Clear
        if (data.length === 0) {
            tbody.innerHTML = `<tr><td colspan="5" class="text-center p-4">No data to display.</td></tr>`;
            return;
        }
        
        data.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${row.chainage.toFixed(2)}</td>
                <td>${row.cutArea.toFixed(2)}</td>
                <td>${row.fillArea.toFixed(2)}</td>
                <td>${row.cutVol.toFixed(2)}</td>
                <td>${row.fillVol.toFixed(2)}</td>
            `;
            tbody.appendChild(tr);
        });
    },

    clear() {
        App.state.reportData = [];
        const tbody = document.querySelector("#report-table tbody");
        tbody.innerHTML = `<tr><td colspan="5" class="text-center p-4">Report not generated.</td></tr>`;
        UI.updateSummary(0, 0, 0);
        document.getElementById('summary-box').classList.add('hidden');
    },

    exportCSV() {
        if (App.state.reportData.length === 0) {
            UI.handleError("No report data to export.");
            return;
        }
        const headers = "Chainage (m),Cut Area (m^2),Fill Area (m^2),Cut Volume (m^3),Fill Volume (m^3)";
        const rows = App.state.reportData.map(r => 
            `${r.chainage.toFixed(2)},${r.cutArea.toFixed(2)},${r.fillArea.toFixed(2)},${r.cutVol.toFixed(2)},${r.fillVol.toFixed(2)}`
        );
        
        const csvContent = "data:text/csv;charset=utf-8," + headers + "\n" + rows.join("\n");
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "earthwork_report.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
};

// ===================================================================================
// UI EVENT HANDLERS & UPDATES
// ===================================================================================
const UI = {
    pflMode: 'none', // 'gradient' or 'ip'
    gradientP1: null,
    
    initEventListeners() {
        // File Input
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const extension = file.name.split('.').pop().toLowerCase();
                App.processNewData(event.target.result, `.${extension}`);
            };
            reader.readAsText(file);
        });
        
        // PFL Buttons
        document.getElementById('btn-set-gradient').addEventListener('click', () => {
            this.pflMode = 'gradient';
            this.gradientP1 = null;
            this.updateStatus("PFL Mode: SET GRADIENT. Click start point on L-Section.", "blue");
        });
        document.getElementById('btn-add-ip').addEventListener('click', () => {
            this.pflMode = 'ip';
            this.updateStatus("PFL Mode: ADD IP. Click Intersection Points on L-Section.", "blue");
        });
        document.getElementById('btn-reset-pfl').addEventListener('click', () => {
             App.resetPFL();
             this.updateStatus("PFL has been reset.", "blue");
        });
        
        // Report Buttons
        document.getElementById('btn-generate-report').addEventListener('click', () => Report.generate());
        document.getElementById('btn-export-csv').addEventListener('click', () => Report.exportCSV());
    },

    // Handles clicks on the L-Section for PFL design
    handleLSectionClick(point) {
        if (this.pflMode === 'gradient') {
            if (!this.gradientP1) {
                this.gradientP1 = point;
                this.updateStatus(`Start point set at Ch: ${point.chainage.toFixed(2)}. Click end point.`, "blue");
            } else {
                App.setPFLWithGradient(this.gradientP1, point);
                this.gradientP1 = null;
                this.pflMode = 'none'; // Reset mode
            }
        } else if (this.pflMode === 'ip') {
            App.addPFLIP(point);
        }
    },
    
    updatePFLList() {
        const container = document.getElementById('ip-list');
        container.innerHTML = '';
        const ips = App.state.pfl.points;
        ips.forEach((ip, index) => {
            if(App.state.pfl.type === 'ips' && index > 0 && index < ips.length - 1) {
                 const div = document.createElement('div');
                 div.className = "flex items-center gap-2 mt-1";
                 div.innerHTML = `
                    <label for="vc-${index}" class="whitespace-nowrap">VC at IP ${index+1}:</label>
                    <input type="number" id="vc-${index}" value="${ip.curveLength || 0}" class="w-full border p-1 rounded">
                 `;
                 container.appendChild(div);
                 document.getElementById(`vc-${index}`).addEventListener('change', (e) => {
                     ip.curveLength = parseFloat(e.target.value) || 0;
                     App.calculateVerticalCurves();
                     Viz.LSection.draw(App.state.centerline, App.getPFLAtChainage);
                 });
            }
        });
    },

    // Broadcasts chainage from L-Section to other components
    broadcastChainage(chainage) {
        if (chainage < 0) return;
        Viz.XSection.draw(chainage);
        // Future: Update 3D view cursor
    },
    
    // Update status message bar
    updateStatus(message, color) {
        const el = document.getElementById('status-message');
        el.textContent = message;
        const colors = { blue: 'text-blue-600', green: 'text-green-600', orange: 'text-orange-500', red: 'text-red-600' };
        el.className = `text-sm font-medium ${colors[color] || 'text-slate-600'}`;
    },
    
    // Show error messages (could be a modal in a real app)
    handleError(message) {
        this.updateStatus(`Error: ${message}`, "red");
        alert(`Error: ${message}`);
    },

    // Update cross-section info panel
    updateXSectionInfo(chainage, cutArea, fillArea) {
        document.getElementById('xsection-chainage').textContent = chainage.toFixed(2);
        document.getElementById('xsection-cut-area').textContent = cutArea.toFixed(2);
        document.getElementById('xsection-fill-area').textContent = fillArea.toFixed(2);
    },
    
    // Update summary report box
    updateSummary(cut, fill, cost) {
        document.getElementById('total-cut').textContent = `${cut.toFixed(2)} m¬≥`;
        document.getElementById('total-fill').textContent = `${fill.toFixed(2)} m¬≥`;
        document.getElementById('total-cost').textContent = `‚Çπ ${cost.toLocaleString('en-IN', { maximumFractionDigits: 2 })}`;
        document.getElementById('summary-box').classList.remove('hidden');
    }
};

// ===================================================================================
// HELPER LOGIC (e.g., Cross-Section calculations)
// ===================================================================================
const XSectionHelper = {
    // This is the core data slicing and calculation logic for cross-sections.
    generate(chainage) {
        const { rawPoints, centerline } = App.state;
        const pfl = App.getPFLAtChainage(chainage);
        if (centerline.length < 2 || rawPoints.length < 3 || pfl === null) return null;
        
        // 1. Find centerline segment and orientation for the given chainage
        let p1, p2;
        for (let i = 0; i < centerline.length - 1; i++) {
            if (chainage >= centerline[i].chainage && chainage <= centerline[i+1].chainage) {
                p1 = centerline[i];
                p2 = centerline[i+1];
                break;
            }
        }
        if (!p1) return null; // Chainage out of bounds
        
        const segmentDx = p2.x - p1.x;
        const segmentDy = p2.y - p1.y;
        const segmentLen = Math.sqrt(segmentDx*segmentDx + segmentDy*segmentDy);
        const t = (chainage - p1.chainage) / segmentLen;
        const clPoint = { x: p1.x + t * segmentDx, y: p1.y + t * segmentDy };

        // Normal vector to the centerline (for slicing)
        const nx = -segmentDy / segmentLen;
        const ny = segmentDx / segmentLen;

        // 2. Slice EGL: Find raw points near the cross-section line
        const sliceWidth = 50; // Look 50m on either side
        const eglPoints = [];
        rawPoints.forEach(p => {
            const vx = p.x - clPoint.x;
            const vy = p.y - clPoint.y;
            const distAlongNormal = vx * nx + vy * ny; // Projection onto normal vector
            const distAlongCL = Math.abs(vx * (segmentDx/segmentLen) + vy * (segmentDy/segmentLen));

            if (Math.abs(distAlongNormal) < sliceWidth && distAlongCL < 1.0) { // Within 1m of the chainage line
                 eglPoints.push({ x: distAlongNormal, y: p.z }); // x is offset from CL, y is elevation
            }
        });
        eglPoints.sort((a,b) => a.x - b.x);
        if (eglPoints.length < 2) return { egl: [], road: [], cutArea: [], fillArea: [], cutAreaValue: 0, fillAreaValue: 0 };


        // 3. Generate Road Template
        const { carriagewayWidth, shoulderWidth, camberSlope, shoulderSlope, cutSlope, fillSlope } = App.state.config;
        const cw_h = carriagewayWidth / 2;
        const sh_w = shoulderWidth;
        const camb_z = cw_h * (camberSlope / 100);
        const sh_z = sh_w * (shoulderSlope / 100);

        const roadTemplate = [
            { x: -(cw_h + sh_w), y: pfl + camb_z + sh_z }, // Left shoulder edge
            { x: -cw_h, y: pfl + camb_z },                 // Left carriageway edge
            { x: 0, y: pfl },                              // Crown (centerline)
            { x: cw_h, y: pfl + camb_z },                 // Right carriageway edge
            { x: cw_h + sh_w, y: pfl + camb_z + sh_z },   // Right shoulder edge
        ];
        
        // 4. Find daylight points (intersection of cut/fill slope with EGL)
        const getEglYatX = (x) => {
            // simple linear interpolation of EGL points
            if (x <= eglPoints[0].x) return eglPoints[0].y;
            if (x >= eglPoints[eglPoints.length-1].x) return eglPoints[eglPoints.length-1].y;
            for(let i=0; i < eglPoints.length-1; i++) {
                if (x >= eglPoints[i].x && x <= eglPoints[i+1].x) {
                    const p1 = eglPoints[i], p2 = eglPoints[i+1];
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + t * (p2.y - p1.y);
                }
            }
            return eglPoints[0].y;
        };

        // Left side
        const leftFormation = roadTemplate[0];
        let leftDaylight;
        const leftDiff = leftFormation.y - getEglYatX(leftFormation.x);
        if (leftDiff > 0) { // Fill
            const slope = -1 / fillSlope;
            const x_intersect = this.findIntersection(leftFormation, slope, eglPoints);
            leftDaylight = {x: x_intersect, y: getEglYatX(x_intersect)};
        } else { // Cut
            const slope = 1 / cutSlope;
            const x_intersect = this.findIntersection(leftFormation, slope, eglPoints);
            leftDaylight = {x: x_intersect, y: getEglYatX(x_intersect)};
        }
        roadTemplate.unshift(leftDaylight);

        // Right side
        const rightFormation = roadTemplate[roadTemplate.length - 1];
        let rightDaylight;
        const rightDiff = rightFormation.y - getEglYatX(rightFormation.x);
        if (rightDiff > 0) { // Fill
            const slope = 1 / fillSlope;
            const x_intersect = this.findIntersection(rightFormation, slope, eglPoints);
            rightDaylight = {x: x_intersect, y: getEglYatX(x_intersect)};
        } else { // Cut
            const slope = -1 / cutSlope;
            const x_intersect = this.findIntersection(rightFormation, slope, eglPoints);
            rightDaylight = {x: x_intersect, y: getEglYatX(x_intersect)};
        }
        roadTemplate.push(rightDaylight);

        // 5. Calculate Cut/Fill polygons and areas
        const { cutPoly, fillPoly } = this.splitByIntersection(eglPoints, roadTemplate);
        const cutAreaVal = this.shoelace(cutPoly);
        const fillAreaVal = this.shoelace(fillPoly);

        return { egl: eglPoints, road: roadTemplate, cutArea: cutPoly, fillArea: fillPoly, cutAreaValue: cutAreaVal, fillAreaValue: fillAreaVal };
    },
    
    // Iteratively finds intersection of a line (from p0 with slope) and a polyline (egl)
    findIntersection(p0, slope, egl) {
       let x_current = p0.x;
       for (let i=0; i<10; i++) { // Iterate to find a stable solution
           const y_egl = egl.find(p => p.x >= x_current)?.y || egl[egl.length-1].y;
           const y_slope = p0.y + slope * (x_current - p0.x);
           const diff = y_slope - y_egl;
           x_current -= diff/slope; // Newton-Raphson-like step, simplified
           if(Math.abs(diff) < 0.01) break;
       }
       return x_current;
    },

    // Splits the area between EGL and Road into cut and fill polygons
    splitByIntersection(egl, road) {
       // This is a complex geometric problem. A simplified approach for visualization:
       const cutPoly = [], fillPoly = [];
       const combined = [...road, ...egl.slice().reverse()]; // Create a closed loop
       // A proper implementation requires boolean polygon operations (clipping)
       // For this mockup, we'll calculate area based on which line is higher.
       
       // Shoelace formula requires ordered vertices of a polygon.
       // The intersection logic is non-trivial. Returning placeholder areas.
       // A practical approximation is to sample points and sum trapezoids.
       let cutArea = 0, fillArea = 0;
       const minX = Math.min(road[0].x, egl[0].x);
       const maxX = Math.max(road[road.length-1].x, egl[egl.length-1].x);
       const step = 0.1;

       for(let x = minX; x < maxX; x += step) {
           const y_road1 = this.getYatX(road, x);
           const y_egl1 = this.getYatX(egl, x);
           const y_road2 = this.getYatX(road, x+step);
           const y_egl2 = this.getYatX(egl, x+step);

           if(y_road1 === null || y_egl1 === null || y_road2 === null || y_egl2 === null) continue;

           const diff1 = y_road1 - y_egl1;
           const diff2 = y_road2 - y_egl2;
           
           const avg_height = Math.abs(diff1 + diff2) / 2;
           const area = avg_height * step;

           if(diff1 > 0 && diff2 > 0) { // Road is above EGL -> Fill
                fillArea += area;
           } else if (diff1 < 0 && diff2 < 0) { // Road is below EGL -> Cut
                cutArea += area;
           } // Ignore mixed segments for simplicity
       }

       return { cutPoly: [], fillPoly: [], cutAreaValue: cutArea, fillAreaValue: fillArea };
    },

    // Helper to get Y value on a polyline at a given X
    getYatX(polyline, x) {
        if (x < polyline[0].x || x > polyline[polyline.length-1].x) return null;
        for(let i=0; i < polyline.length-1; i++) {
            const p1 = polyline[i], p2 = polyline[i+1];
            if (x >= p1.x && x <= p2.x) {
                const t = (p2.x - p1.x) === 0 ? 0 : (x - p1.x) / (p2.x - p1.x);
                return p1.y + t * (p2.y - p1.y);
            }
        }
        return null;
    },
    
    // Shoelace formula to calculate area of a polygon
    shoelace(vertices) {
        let area = 0;
        for (let i = 0; i < vertices.length; i++) {
            const j = (i + 1) % vertices.length;
            area += vertices[i].x * vertices[j].y;
            area -= vertices[j].x * vertices[i].y;
        }
        return Math.abs(area / 2.0);
    },

};

// ===================================================================================
// START THE APP
// ===================================================================================
document.addEventListener("DOMContentLoaded", () => {
    App.init();
});

</script>
</body>
</html>
