<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Road Survey Data Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
            text-align: center;
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.2em;
        }
        
        .control-panel {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }
        
        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .control-group input,
        .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .vis-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .vis-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .vis-content {
            padding: 20px;
            height: 400px;
            position: relative;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .results-panel {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e6ed;
        }
        
        .results-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .status-indicator {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-ready {
            background: #d4edda;
            color: #155724;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e6ed;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        #threejs-container {
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .chart-container {
            width: 100%;
            height: 100%;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .summary-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .summary-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .summary-card p {
            opacity: 0.9;
        }
        
        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
            
            .control-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Road Survey Data Analyzer</h1>
            <p>Professional earthwork analysis tool for Indian road projects</p>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group">
                    <label>Survey Data File (.sdr/.csv)</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="surveyFile" accept=".sdr,.csv">
                        <label for="surveyFile" class="file-input-label">
                            Choose Survey File
                        </label>
                    </div>
                    <div id="fileStatus" class="status-indicator" style="margin-top: 10px; display: none;"></div>
                </div>
                
                <div class="control-group">
                    <label>Road Width (m)</label>
                    <input type="number" id="roadWidth" value="7.0" step="0.1" min="3" max="20">
                </div>
                
                <div class="control-group">
                    <label>Camber (%)</label>
                    <input type="number" id="camber" value="2.5" step="0.1" min="1" max="5">
                </div>
                
                <div class="control-group">
                    <label>Cut Side Slope (H:V)</label>
                    <input type="text" id="cutSlope" value="1:1" placeholder="e.g., 1:1">
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <label>Fill Side Slope (H:V)</label>
                    <input type="text" id="fillSlope" value="2:1" placeholder="e.g., 2:1">
                </div>
                
                <div class="control-group">
                    <label>Cut Rate (₹/m³)</label>
                    <input type="number" id="cutRate" value="150" step="1" min="50">
                </div>
                
                <div class="control-group">
                    <label>Fill Rate (₹/m³)</label>
                    <input type="number" id="fillRate" value="200" step="1" min="50">
                </div>
                
                <div class="control-group">
                    <label>Cross-Section Interval (m)</label>
                    <input type="number" id="sectionInterval" value="20" step="5" min="10" max="100">
                </div>
            </div>
            
            <div class="control-row">
                <button class="btn btn-primary" onclick="processData()">Process Survey Data</button>
                <button class="btn btn-secondary" onclick="generateReport()">Generate Report</button>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="visualization-container">
            <div class="vis-panel">
                <div class="vis-header">3D Terrain Visualization</div>
                <div class="vis-content">
                    <div id="threejs-container"></div>
                </div>
            </div>
            
            <div class="vis-panel">
                <div class="vis-header">Plan View</div>
                <div class="vis-content">
                    <div id="plan-view" class="chart-container"></div>
                </div>
            </div>
            
            <div class="vis-panel">
                <div class="vis-header">Longitudinal Section</div>
                <div class="vis-content">
                    <div id="longitudinal-section" class="chart-container"></div>
                </div>
            </div>
            
            <div class="vis-panel">
                <div class="vis-header">Cross-Section View</div>
                <div class="vis-content">
                    <div id="cross-section" class="chart-container"></div>
                    <div style="text-align: center; margin-top: 10px;">
                        <input type="range" id="chainageSlider" min="0" max="100" value="0" style="width: 80%;">
                        <div id="chainageDisplay">Chainage: 0m</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="results-panel">
            <h2>Volume & Cost Analysis</h2>
            
            <div class="summary-cards" id="summaryCards">
                <div class="summary-card">
                    <h3 id="totalCut">0</h3>
                    <p>Total Cut (m³)</p>
                </div>
                <div class="summary-card">
                    <h3 id="totalFill">0</h3>
                    <p>Total Fill (m³)</p>
                </div>
                <div class="summary-card">
                    <h3 id="netVolume">0</h3>
                    <p>Net Volume (m³)</p>
                </div>
                <div class="summary-card">
                    <h3 id="totalCost">₹0</h3>
                    <p>Estimated Cost</p>
                </div>
            </div>
            
            <table class="results-table" id="resultsTable">
                <thead>
                    <tr>
                        <th>Chainage (m)</th>
                        <th>EGL (m)</th>
                        <th>PFL (m)</th>
                        <th>Cut Vol (m³)</th>
                        <th>Fill Vol (m³)</th>
                        <th>Cost (₹)</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Core Application Class
        class RoadSurveyAnalyzer {
            constructor() {
                this.surveyData = [];
                this.processedData = [];
                this.roadParams = {};
                this.volumes = [];
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.initThreeJS();
            }
            
            setupEventListeners() {
                document.getElementById('surveyFile').addEventListener('change', (e) => {
                    this.loadSurveyFile(e.target.files[0]);
                });
                
                document.getElementById('chainageSlider').addEventListener('input', (e) => {
                    this.updateCrossSection(parseFloat(e.target.value));
                });
            }
            
            initThreeJS() {
                const container = document.getElementById('threejs-container');
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(50, 50, 50);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(100, 100, 50);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // Grid
                const gridHelper = new THREE.GridHelper(200, 20);
                this.scene.add(gridHelper);
                
                this.animate();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Simple camera rotation
                if (this.surveyData.length > 0) {
                    this.camera.position.x = Math.cos(Date.now() * 0.0005) * 100;
                    this.camera.position.z = Math.sin(Date.now() * 0.0005) * 100;
                    this.camera.lookAt(0, 0, 0);
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            async loadSurveyFile(file) {
                if (!file) return;
                
                const status = document.getElementById('fileStatus');
                status.style.display = 'block';
                status.textContent = 'Loading file...';
                status.className = 'status-indicator';
                
                try {
                    const text = await file.text();
                    const extension = file.name.split('.').pop().toLowerCase();
                    
                    if (extension === 'sdr') {
                        this.surveyData = this.parseSDRFile(text);
                    } else if (extension === 'csv') {
                        this.surveyData = this.parseCSVFile(text);
                    } else {
                        throw new Error('Unsupported file format');
                    }
                    
                    status.textContent = `Loaded ${this.surveyData.length} survey points`;
                    status.className = 'status-indicator status-ready';
                    
                    this.updateVisualization();
                    
                } catch (error) {
                    status.textContent = `Error: ${error.message}`;
                    status.className = 'status-indicator status-error';
                }
            }
            
            parseSDRFile(text) {
                const lines = text.split('\\n');
                const points = [];
                
                lines.forEach(line => {
                    line = line.trim();
                    if (line.startsWith('08KI')) {
                        // Basic SDR parsing - this would need to be more sophisticated
                        const parts = line.split(' ');
                        if (parts.length >= 4) {
                            points.push({
                                point: parts[1] || `P${points.length + 1}`,
                                n: parseFloat(parts[2]) || 0,
                                e: parseFloat(parts[3]) || 0,
                                z: parseFloat(parts[4]) || 0,
                                code: parts[5] || 'GP'
                            });
                        }
                    }
                });
                
                // Generate sample data if no valid points found
                if (points.length === 0) {
                    return this.generateSampleData();
                }
                
                return points;
            }
            
            parseCSVFile(text) {
                const lines = text.split('\\n');
                const points = [];
                
                // Skip header line
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const parts = line.split(',');
                        if (parts.length >= 4) {
                            points.push({
                                point: parts[0] || `P${i}`,
                                n: parseFloat(parts[1]) || 0,
                                e: parseFloat(parts[2]) || 0,
                                z: parseFloat(parts[3]) || 0,
                                code: parts[4] || 'GP'
                            });
                        }
                    }
                }
                
                // Generate sample data if no valid points found
                if (points.length === 0) {
                    return this.generateSampleData();
                }
                
                return points;
            }
            
            generateSampleData() {
                // Generate realistic survey data for demonstration
                const points = [];
                
                // Main centerline points
                for (let i = 0; i <= 1000; i += 20) {
                    const chainage = i;
                    const elevation = 100 + Math.sin(i * 0.01) * 5 + Math.random() * 2;
                    
                    // Centerline
                    points.push({
                        point: `CL${i}`,
                        n: 1000,
                        e: chainage,
                        z: elevation,
                        code: 'CL'
                    });
                    
                    // Left side points
                    for (let j = 1; j <= 3; j++) {
                        points.push({
                            point: `L${i}_${j * 5}`,
                            n: 1000 + j * 5,
                            e: chainage + Math.random() * 2 - 1,
                            z: elevation + Math.random() * 3 - 1.5,
                            code: 'GP'
                        });
                    }
                    
                    // Right side points
                    for (let j = 1; j <= 3; j++) {
                        points.push({
                            point: `R${i}_${j * 5}`,
                            n: 1000 - j * 5,
                            e: chainage + Math.random() * 2 - 1,
                            z: elevation + Math.random() * 3 - 1.5,
                            code: 'GP'
                        });
                    }
                }
                
                return points;
            }
            
            updateVisualization() {
                this.create3DTerrain();
                this.createPlanView();
                this.createLongitudinalSection();
                this.setupCrossSectionSlider();
            }
            
            create3DTerrain() {
                // Clear existing terrain
                const terrainObjects = this.scene.children.filter(obj => obj.userData.isTerrain);
                terrainObjects.forEach(obj => this.scene.remove(obj));
                
                if (this.surveyData.length === 0) return;
                
                // Create point cloud
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                this.surveyData.forEach(point => {
                    positions.push(point.e - 500, point.z - 100, point.n - 1000);
                    
                    // Color based on code
                    if (point.code === 'CL') {
                        colors.push(1, 0, 0); // Red for centerline
                    } else {
                        colors.push(0.2, 0.8, 0.2); // Green for ground points
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({ size: 2, vertexColors: true });
                const points = new THREE.Points(geometry, material);
                points.userData.isTerrain = true;
                this.scene.add(points);
                
                // Create surface mesh using Delaunay triangulation (simplified)
                this.createTerrainMesh();
            }
            
            createTerrainMesh() {
                // Simplified terrain mesh creation
                const centerlinePoints = this.surveyData.filter(p => p.code === 'CL');
                if (centerlinePoints.length < 2) return;
                
                const geometry = new THREE.PlaneGeometry(1000, 100, 50, 10);
                const vertices = geometry.attributes.position;
                
                // Modify vertices based on survey data
                for (let i = 0; i < vertices.count; i++) {
                    const x = vertices.getX(i);
                    const z = vertices.getZ(i);
                    
                    // Simple interpolation based on distance to centerline points
                    let elevation = 0;
                    let totalWeight = 0;
                    
                    centerlinePoints.forEach(point => {
                        const distance = Math.sqrt(Math.pow(x - (point.e - 500), 2) + Math.pow(z - (point.n - 1000), 2));
                        const weight = 1 / (distance + 1);
                        elevation += (point.z - 100) * weight;
                        totalWeight += weight;
                    });
                    
                    vertices.setY(i, elevation / totalWeight);
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x90EE90, 
                    transparent: true, 
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData.isTerrain = true;
                this.scene.add(mesh);
            }
            
            createPlanView() {
                const container = d3.select('#plan-view');
                container.selectAll('*').remove();
                
                if (this.surveyData.length === 0) return;
                
                const margin = { top: 20, right: 20, bottom: 40, left: 60 };
                const width = container.node().clientWidth - margin.left - margin.right;
                const height = container.node().clientHeight - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Scales
                const xExtent = d3.extent(this.surveyData, d => d.e);
                const yExtent = d3.extent(this.surveyData, d => d.n);
                
                const xScale = d3.scaleLinear()
                    .domain(xExtent)
                    .range([0, width]);
                
                const yScale = d3.scaleLinear()
                    .domain(yExtent)
                    .range([height, 0]);
                
                // Axes
                g.append('g')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', width / 2)
                    .attr('y', 35)
                    .style('text-anchor', 'middle')
                    .text('Easting (m)');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -45)
                    .attr('x', -height / 2)
                    .style('text-anchor', 'middle')
                    .text('Northing (m)');
                
                // Plot points
                g.selectAll('.survey-point')
                    .data(this.surveyData)
                    .enter().append('circle')
                    .attr('class', 'survey-point')
                    .attr('cx', d => xScale(d.e))
                    .attr('cy', d => yScale(d.n))
                    .attr('r', d => d.code === 'CL' ? 4 : 2)
                    .attr('fill', d => d.code === 'CL' ? '#e74c3c' : '#27ae60')
                    .attr('opacity', 0.7);
                
                // Centerline
                const centerlinePoints = this.surveyData.filter(p => p.code === 'CL');
                if (centerlinePoints.length > 1) {
                    const line = d3.line()
                        .x(d => xScale(d.e))
                        .y(d => yScale(d.n));
                    
                    g.append('path')
                        .datum(centerlinePoints)
                        .attr('fill', 'none')
                        .attr('stroke', '#e74c3c')
                        .attr('stroke-width', 2)
                        .attr('d', line);
                }
            }
            
            createLongitudinalSection() {
                const container = d3.select('#longitudinal-section');
                container.selectAll('*').remove();
                
                const centerlinePoints = this.surveyData.filter(p => p.code === 'CL');
                if (centerlinePoints.length === 0) return;
                
                const margin = { top: 20, right: 20, bottom: 40, left: 60 };
                const width = container.node().clientWidth - margin.left - margin.right;
                const height = container.node().clientHeight - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Calculate chainages
                const chainageData = centerlinePoints.map((point, i) => ({
                    chainage: i * 20, // Assuming 20m intervals
                    egl: point.z,
                    pfl: point.z - 1 // Sample proposed formation level
                }));
                
                // Scales
                const xScale = d3.scaleLinear()
                    .domain(d3.extent(chainageData, d => d.chainage))
                    .range([0, width]);
                
                const yScale = d3.scaleLinear()
                    .domain(d3.extent(chainageData, d => Math.min(d.egl, d.pfl)))
                    .range([height, 0]);
                
                // Axes
                g.append('g')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', width / 2)
                    .attr('y', 35)
                    .style('text-anchor', 'middle')
                    .text('Chainage (m)');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -45)
                    .attr('x', -height / 2)
                    .style('text-anchor', 'middle')
                    .text('Elevation (m)');
                
                // EGL Line
                const eglLine = d3.line()
                    .x(d => xScale(d.chainage))
                    .y(d => yScale(d.egl));
                
                g.append('path')
                    .datum(chainageData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2)
                    .attr('d', eglLine);
                
                // PFL Line
                const pflLine = d3.line()
                    .x(d => xScale(d.chainage))
                    .y(d => yScale(d.pfl));
                
                g.append('path')
                    .datum(chainageData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .attr('d', pflLine);
                
                // Legend
                const legend = g.append('g')
                    .attr('transform', `translate(${width - 100}, 20)`);
                
                legend.append('line')
                    .attr('x1', 0).attr('x2', 20)
                    .attr('y1', 0).attr('y2', 0)
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2);
                
                legend.append('text')
                    .attr('x', 25).attr('y', 5)
                    .text('EGL');
                
                legend.append('line')
                    .attr('x1', 0).attr('x2', 20)
                    .attr('y1', 15).attr('y2', 15)
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                legend.append('text')
                    .attr('x', 25).attr('y', 20)
                    .text('PFL');
            }
            
            setupCrossSectionSlider() {
                const centerlinePoints = this.surveyData.filter(p => p.code === 'CL');
                if (centerlinePoints.length === 0) return;
                
                const slider = document.getElementById('chainageSlider');
                const maxChainage = (centerlinePoints.length - 1) * 20;
                slider.max = maxChainage;
                slider.step = 20;
                
                this.updateCrossSection(0);
            }
            
            updateCrossSection(chainage) {
                document.getElementById('chainageDisplay').textContent = `Chainage: ${chainage}m`;
                
                const container = d3.select('#cross-section');
                container.selectAll('*').remove();
                
                // Find points near this chainage
                const sectionIndex = Math.round(chainage / 20);
                const sectionPoints = this.getSectionPoints(sectionIndex);
                
                if (sectionPoints.length === 0) return;
                
                const margin = { top: 20, right: 20, bottom: 40, left: 60 };
                const width = container.node().clientWidth - margin.left - margin.right;
                const height = container.node().clientHeight - margin.top - margin.bottom - 50;
                
                const svg = container.append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom);
                
                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Calculate road parameters
                const roadWidth = parseFloat(document.getElementById('roadWidth').value);
                const camber = parseFloat(document.getElementById('camber').value);
                
                // Find centerline point
                const centerlinePoint = sectionPoints.find(p => p.offset === 0);
                if (!centerlinePoint) return;
                
                // Create cross-section data
                const crossSectionData = this.generateCrossSectionData(sectionPoints, centerlinePoint, roadWidth, camber);
                
                // Scales
                const xScale = d3.scaleLinear()
                    .domain(d3.extent(crossSectionData, d => d.offset))
                    .range([0, width]);
                
                const yScale = d3.scaleLinear()
                    .domain(d3.extent(crossSectionData, d => Math.min(d.egl, d.pfl)))
                    .range([height, 0]);
                
                // Axes
                g.append('g')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(xScale))
                    .append('text')
                    .attr('x', width / 2)
                    .attr('y', 35)
                    .style('text-anchor', 'middle')
                    .text('Offset (m)');
                
                g.append('g')
                    .call(d3.axisLeft(yScale))
                    .append('text')
                    .attr('transform', 'rotate(-90)')
                    .attr('y', -45)
                    .attr('x', -height / 2)
                    .style('text-anchor', 'middle')
                    .text('Elevation (m)');
                
                // Ground line
                const groundLine = d3.line()
                    .x(d => xScale(d.offset))
                    .y(d => yScale(d.egl));
                
                g.append('path')
                    .datum(crossSectionData)
                    .attr('fill', 'none')
                    .attr('stroke', '#2c3e50')
                    .attr('stroke-width', 2)
                    .attr('d', groundLine);
                
                // Road formation line
                const formationLine = d3.line()
                    .x(d => xScale(d.offset))
                    .y(d => yScale(d.pfl));
                
                g.append('path')
                    .datum(crossSectionData)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 3)
                    .attr('d', formationLine);
                
                // Fill areas
                const area = d3.area()
                    .x(d => xScale(d.offset))
                    .y0(d => yScale(d.pfl))
                    .y1(d => yScale(d.egl));
                
                crossSectionData.forEach((d, i) => {
                    if (i < crossSectionData.length - 1) {
                        const nextPoint = crossSectionData[i + 1];
                        const isCut = d.egl > d.pfl || nextPoint.egl > nextPoint.pfl;
                        const color = isCut ? '#ff6b6b' : '#51cf66';
                        const opacity = 0.3;
                        
                        g.append('path')
                            .datum([d, nextPoint])
                            .attr('fill', color)
                            .attr('opacity', opacity)
                            .attr('d', area);
                    }
                });
                
                // Plot points
                g.selectAll('.section-point')
                    .data(crossSectionData)
                    .enter().append('circle')
                    .attr('class', 'section-point')
                    .attr('cx', d => xScale(d.offset))
                    .attr('cy', d => yScale(d.egl))
                    .attr('r', 3)
                    .attr('fill', '#2c3e50');
            }
            
            getSectionPoints(sectionIndex) {
                // Get points for a specific cross-section
                const centerlinePoints = this.surveyData.filter(p => p.code === 'CL');
                if (sectionIndex >= centerlinePoints.length) return [];
                
                const centerPoint = centerlinePoints[sectionIndex];
                const sectionPoints = [];
                
                // Find all points near this chainage
                this.surveyData.forEach(point => {
                    const distance = Math.sqrt(
                        Math.pow(point.e - centerPoint.e, 2) + 
                        Math.pow(point.n - centerPoint.n, 2)
                    );
                    
                    if (distance < 50) { // Within 50m of centerline
                        const offset = point.n - centerPoint.n; // Simplified offset calculation
                        sectionPoints.push({
                            ...point,
                            offset: offset,
                            distance: distance
                        });
                    }
                });
                
                return sectionPoints.sort((a, b) => a.offset - b.offset);
            }
            
            generateCrossSectionData(sectionPoints, centerPoint, roadWidth, camber) {
                const data = [];
                const halfWidth = roadWidth / 2;
                
                // Generate points from left to right
                for (let offset = -20; offset <= 20; offset += 2) {
                    // Interpolate ground elevation
                    let egl = centerPoint.z;
                    if (sectionPoints.length > 0) {
                        // Simple inverse distance weighting
                        let weightedSum = 0;
                        let totalWeight = 0;
                        
                        sectionPoints.forEach(point => {
                            const weight = 1 / (Math.abs(point.offset - offset) + 1);
                            weightedSum += point.z * weight;
                            totalWeight += weight;
                        });
                        
                        if (totalWeight > 0) {
                            egl = weightedSum / totalWeight;
                        }
                    }
                    
                    // Calculate proposed formation level with camber
                    let pfl = centerPoint.z - 1; // 1m below centerline as default
                    if (Math.abs(offset) <= halfWidth) {
                        // Apply camber within road width
                        const camberFactor = camber / 100;
                        pfl = pfl - Math.abs(offset) * camberFactor;
                    }
                    
                    data.push({
                        offset: offset,
                        egl: egl,
                        pfl: pfl
                    });
                }
                
                return data;
            }
            
            getRoadParameters() {
                return {
                    roadWidth: parseFloat(document.getElementById('roadWidth').value),
                    camber: parseFloat(document.getElementById('camber').value),
                    cutSlope: document.getElementById('cutSlope').value,
                    fillSlope: document.getElementById('fillSlope').value,
                    cutRate: parseFloat(document.getElementById('cutRate').value),
                    fillRate: parseFloat(document.getElementById('fillRate').value),
                    sectionInterval: parseFloat(document.getElementById('sectionInterval').value)
                };
            }
            
            calculateVolumes() {
                const params = this.getRoadParameters();
                const centerlinePoints = this.surveyData.filter(p => p.code === 'CL');
                const volumes = [];
                let totalCut = 0;
                let totalFill = 0;
                let totalCost = 0;
                
                for (let i = 0; i < centerlinePoints.length - 1; i++) {
                    const chainage = i * params.sectionInterval;
                    const sectionPoints1 = this.getSectionPoints(i);
                    const sectionPoints2 = this.getSectionPoints(i + 1);
                    
                    const area1 = this.calculateSectionArea(sectionPoints1, centerlinePoints[i], params);
                    const area2 = this.calculateSectionArea(sectionPoints2, centerlinePoints[i + 1], params);
                    
                    // Average end area method
                    const cutVolume = ((area1.cut + area2.cut) / 2) * params.sectionInterval;
                    const fillVolume = ((area1.fill + area2.fill) / 2) * params.sectionInterval;
                    
                    const cost = cutVolume * params.cutRate + fillVolume * params.fillRate;
                    
                    volumes.push({
                        chainage: chainage,
                        egl: centerlinePoints[i].z,
                        pfl: centerlinePoints[i].z - 1,
                        cutVolume: cutVolume,
                        fillVolume: fillVolume,
                        cost: cost
                    });
                    
                    totalCut += cutVolume;
                    totalFill += fillVolume;
                    totalCost += cost;
                }
                
                this.volumes = volumes;
                this.updateSummaryCards(totalCut, totalFill, totalCost);
                this.updateResultsTable();
            }
            
            calculateSectionArea(sectionPoints, centerPoint, params) {
                // Simplified area calculation
                let cutArea = 0;
                let fillArea = 0;
                
                const roadWidth = params.roadWidth;
                const halfWidth = roadWidth / 2;
                
                // Calculate areas for simplified trapezoidal sections
                for (let offset = -halfWidth; offset <= halfWidth; offset += 1) {
                    const egl = this.interpolateElevation(sectionPoints, centerPoint, offset);
                    const pfl = centerPoint.z - 1 - Math.abs(offset) * (params.camber / 100);
                    
                    const diff = egl - pfl;
                    if (diff > 0) {
                        cutArea += Math.abs(diff);
                    } else {
                        fillArea += Math.abs(diff);
                    }
                }
                
                return { cut: cutArea, fill: fillArea };
            }
            
            interpolateElevation(sectionPoints, centerPoint, offset) {
                if (sectionPoints.length === 0) return centerPoint.z;
                
                // Find nearest points
                let weightedSum = 0;
                let totalWeight = 0;
                
                sectionPoints.forEach(point => {
                    const weight = 1 / (Math.abs(point.offset - offset) + 1);
                    weightedSum += point.z * weight;
                    totalWeight += weight;
                });
                
                return totalWeight > 0 ? weightedSum / totalWeight : centerPoint.z;
            }
            
            updateSummaryCards(totalCut, totalFill, totalCost) {
                document.getElementById('totalCut').textContent = Math.round(totalCut).toLocaleString();
                document.getElementById('totalFill').textContent = Math.round(totalFill).toLocaleString();
                document.getElementById('netVolume').textContent = Math.round(totalCut - totalFill).toLocaleString();
                document.getElementById('totalCost').textContent = `₹${Math.round(totalCost).toLocaleString()}`;
            }
            
            updateResultsTable() {
                const tbody = document.querySelector('#resultsTable tbody');
                tbody.innerHTML = '';
                
                this.volumes.forEach(vol => {
                    const row = tbody.insertRow();
                    row.insertCell(0).textContent = vol.chainage;
                    row.insertCell(1).textContent = vol.egl.toFixed(2);
                    row.insertCell(2).textContent = vol.pfl.toFixed(2);
                    row.insertCell(3).textContent = Math.round(vol.cutVolume).toLocaleString();
                    row.insertCell(4).textContent = Math.round(vol.fillVolume).toLocaleString();
                    row.insertCell(5).textContent = `₹${Math.round(vol.cost).toLocaleString()}`;
                });
            }
            
            updateProgress(percentage) {
                document.getElementById('progressFill').style.width = `${percentage}%`;
            }
            
            async processData() {
                if (this.surveyData.length === 0) {
                    alert('Please load survey data first');
                    return;
                }
                
                this.updateProgress(20);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                this.updateVisualization();
                this.updateProgress(60);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                this.calculateVolumes();
                this.updateProgress(100);
                
                setTimeout(() => this.updateProgress(0), 2000);
            }
            
            generateReport() {
                if (this.volumes.length === 0) {
                    alert('Please process survey data first');
                    return;
                }
                
                // Generate and download report
                const params = this.getRoadParameters();
                let report = `ROAD SURVEY ANALYSIS REPORT\n`;
                report += `=====================================\n\n`;
                report += `Project Parameters:\n`;
                report += `- Road Width: ${params.roadWidth}m\n`;
                report += `- Camber: ${params.camber}%\n`;
                report += `- Cut Side Slope: ${params.cutSlope}\n`;
                report += `- Fill Side Slope: ${params.fillSlope}\n`;
                report += `- Cut Rate: ₹${params.cutRate}/m³\n`;
                report += `- Fill Rate: ₹${params.fillRate}/m³\n\n`;
                
                report += `Volume Summary:\n`;
                const totalCut = this.volumes.reduce((sum, v) => sum + v.cutVolume, 0);
                const totalFill = this.volumes.reduce((sum, v) => sum + v.fillVolume, 0);
                const totalCost = this.volumes.reduce((sum, v) => sum + v.cost, 0);
                
                report += `- Total Cut: ${Math.round(totalCut).toLocaleString()} m³\n`;
                report += `- Total Fill: ${Math.round(totalFill).toLocaleString()} m³\n`;
                report += `- Net Volume: ${Math.round(totalCut - totalFill).toLocaleString()} m³\n`;
                report += `- Estimated Cost: ₹${Math.round(totalCost).toLocaleString()}\n\n`;
                
                report += `Detailed Breakdown:\n`;
                report += `Chainage\tEGL\tPFL\tCut Vol\tFill Vol\tCost\n`;
                report += `(m)\t(m)\t(m)\t(m³)\t(m³)\t(₹)\n`;
                report += `---------------------------------------------\n`;
                
                this.volumes.forEach(vol => {
                    report += `${vol.chainage}\t${vol.egl.toFixed(2)}\t${vol.pfl.toFixed(2)}\t`;
                    report += `${Math.round(vol.cutVolume)}\t${Math.round(vol.fillVolume)}\t`;
                    report += `${Math.round(vol.cost)}\n`;
                });
                
                // Download report
                const blob = new Blob([report], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'road_survey_report.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }
        
        // Initialize application
        let analyzer;
        
        window.addEventListener('DOMContentLoaded', () => {
            analyzer = new RoadSurveyAnalyzer();
        });
        
        // Global functions for buttons
        function processData() {
            analyzer.processData();
        }
        
        function generateReport() {
            analyzer.generateReport();
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (analyzer && analyzer.renderer) {
                const container = document.getElementById('threejs-container');
                analyzer.camera.aspect = container.clientWidth / container.clientHeight;
                analyzer.camera.updateProjectionMatrix();
                analyzer.renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html>
